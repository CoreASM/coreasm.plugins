// after weaving
CoreASM TestCall5

derived GetBindingValue ( bindingVar , matchingResult )= head ( GetValues ( GetBindings ( bindingVar , matchingResult )))

derived AllEqual ( list )= forall element in tail ( list ) holds element = head ( list )

derived GetIds ( bindinglist )= map ( bindinglist ,@ last )

derived NotBinding ( list )= return res in if list = undef then
	res :=[]
else
	res := undef

derived OrBinding ( list1 , list2 )= return res in local list in
seq
	if list1 = undef and list2 = undef then
		list := undef
	else
		if list1 = undef then
			list := list2
	else
		if list2 = undef then
			list := list1
	else
		list := list1 + list2
next
	if list = undef then
	res := undef
else
	res := toList ({[ GetBindingValue ( id , list ), id ]| id in GetIds ( list )})

derived AndBinding ( list1 , list2 )= return res in local list in
seq
	if list1 = undef or list2 = undef then
		list := undef
	else
		list := list1 + list2
next
	if list = undef then
	res := undef
else
	if forall id in GetIds ( list ) holds AllEqual ( GetValues ( GetBindings ( id , list ))) then
		res := list
else
	res := undef

derived GetValues ( bindinglist )= map ( bindinglist ,@ head )

derived NameEquals ( elem )= last ( elem ) = last ( head ( elem ))

derived GetBindings ( bindingVar , matchingResult )= map ( filter ( zip ( matchingResult , replicate ( bindingVar ,| matchingResult |)),@ NameEquals ),@ head )

derived LastNotUndef ( tuple )= last ( tuple ) != undef

derived ExtractId ( list )= return id in if LIST ( list ) then
	id := last ( list )
else
	id := undef

derived IdsIntoList ( sig , patternsig )= filter ( zip ( sig , map ( patternsig ,@ ExtractId )),@ LastNotUndef )

derived ExtractPattern ( list )= return singleElementList in if LIST ( list ) then
	singleElementList := toString ( head ( list ))
else
	singleElementList := toString ( list )

derived CreateBinding ( sig , ruleSignature )= return binding in let pattern = map ( ruleSignature ,@ ExtractPattern ) in if | sig | = | pattern | then
	if forall c in zipwith ( map ( sig ,@ toString ), pattern ,@ matches ) holds c then
	binding := IdsIntoList ( sig , ruleSignature )
else
	binding := undef
else
	binding := undef

derived Concat ( l1 , l2 )= return res in if l2 = undef then
	res := l1
else
	if l1 = undef then
		res := l2
else
	res := l1 + l2

derived callStackMatches ( ruleSignature )= CheckConsistency ( foldl ( zipwith ( reverse ( callStack ( self )), replicate ( ruleSignature ,| callStack ( self )|),@ CreateBinding ),@ Concat , undef ))

derived CheckConsistency ( list )= return res in if list = undef then
	res := undef
else
	if forall id in GetIds ( list ) holds AllEqual ( GetValues ( GetBindings ( id , list ))) then
		res := list
else
	res := undef
function callStack : Agents -> LIST

use Standard
use AoASMPlugin
aspect {

rule adv0 =
seqblock
	if callStack ( self ) = undef then
		callStack ( self ):=[["adv0"]]
	else
		callStack ( self ):= cons (["adv0"], callStack ( self ))
	par
		if ( true ) then
			{ print "TestCall5"}
	endpar
	callStack ( self ):= tail ( callStack ( self ))
	skip
endseqblock
}
function ruleChooser :-> BOOLEAN initially true

init StartRule

rule StartRule =
seqblock
	if callStack ( self ) = undef then
		callStack ( self ):=[["StartRule"]]
	else
		callStack ( self ):= cons (["StartRule"], callStack ( self ))
	par
		if ruleChooser then
			{
		seqblock
			par
				adv0
			endpar
			DoSomething
			skip
		endseqblock
		ruleChooser := false }
		else
			{
		seqblock
			par
				adv0
			endpar
			DoSomethingElse
			skip
		endseqblock
		ruleChooser := true }
	endpar
	callStack ( self ):= tail ( callStack ( self ))
	skip
endseqblock

rule DoSomething =
seqblock
	if callStack ( self ) = undef then
		callStack ( self ):=[["DoSomething"]]
	else
		callStack ( self ):= cons (["DoSomething"], callStack ( self ))
	par
		print "DoSomething"
	endpar
	callStack ( self ):= tail ( callStack ( self ))
	skip
endseqblock

rule DoSomethingElse =
seqblock
	if callStack ( self ) = undef then
		callStack ( self ):=[["DoSomethingElse"]]
	else
		callStack ( self ):= cons (["DoSomethingElse"], callStack ( self ))
	par
		print "DoSomethingElse"
	endpar
	callStack ( self ):= tail ( callStack ( self ))
	skip
endseqblock
